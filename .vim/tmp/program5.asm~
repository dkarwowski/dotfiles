####
# David Karwowski
# Dylan Leonard
# Siena Biales
# Micheala Forte
# Program 5 - Merge Sort

# merge_sort($a0)
# param:
#   $a0 - Array (first word is length n, then n words following)
# return:
#   $v0 - Array, or null pointer if invalid info given
Merge_Sort:
        # error checking
        blt     $a0, 0x10008000, error
        bgtu    $a0, 0x7FFFFFDC, error
        
        # unaligned address
        srl     $t0, $a0, 2         # shift two to the right
        sll     $t0, $t0, 2         # shift back
        bne     $t0, $a0, error

        # invalid array length
        lw      $t0, 0 ($a0)        # $t0 = a.length
        blt     $t0, $0, error
        sll     $t1, $t0, 2
        addu    $t1, $t1, $a0
        bltu    $t1, $a0, error
        bgeu    $t1, $sp, error

merge_sort_inner:
        # adjust stack
        addi    $sp, $sp, -20       # add to stack
        sw      $ra, 0x00 ($sp)     # store return on stack
        sw      $s0, 0x04 ($sp)
        sw      $s1, 0x08 ($sp)
        sw      $s2, 0x0C ($sp)
        sw      $s3, 0x10 ($sp)

        # if (a.length < 2)
        lw      $t0, 0 ($a0)        # $t0 = a.length
        li      $t1, 2              # $t1 = 2
        blt     $t0, $t1, return    # return a;

        # break the array into halves
        # int l1 = a.length / 2;
        div     $t0, $t1            # $LO = a.length / 2
        mflo    $s0                 # $s0 = l1
        # Array sub1 = new Array(l1);
        li      $t2, -4             # $t2 = -4
        mul     $t2, $t2, $s0       # $t2 = -4 * l1 (sizeof(int) * l1)
        add     $sp, $sp, $t2       # adjust stack by l1
        addi    $sp, $sp, -4        # adjust stack to have l1
        move    $s2, $sp            # $s2 = sub1
        sw      $s0, 0 ($s2)        # set the length in sub1
        # int l2 = a.length - l1
        sub     $s1, $t0, $s0       # $s1 = a.length - l1 = l2
        # Array sub2 = new Array(l2);
        li      $t2, -4             # $t2 = -4
        mul     $t2, $t2, $s1       # $t2 = -4 * l2 (sizeof(int) * l2)
        add     $sp, $sp, $t2       # adjust stack by l2
        addi    $sp, $sp, -4        # adjust stack to have l2
        move    $s3, $sp            # $s3 = sub2
        sw      $s1, 0 ($s3)        # set the length in sub2

        # for (int i = 0; i < l1; i++)
        li      $t0, 0              # $t0 = i = 0
        move    $t1, $a0            # $t1 = a
        move    $t2, $s2            # $t2 = sub1
for_l1:
        addi    $t1, $t1, 4         # $t1 = a[i:]
        addi    $t2, $t2, 4         # $t2 = sub1[i:]
        bge     $t0, $s0, for_l1_done
        # sub1[i] = a[i];
        lw      $t3, 0 ($t1)        # $t3 = a[i]
        sw      $t3, 0 ($t2)        # sub1[i] = $t3
        addi    $t0, $t0, 1         # $t0 = i++
        beq     $0, $0, for_l1
for_l1_done:
        # for (int i = 0; i < l2; i++)
        li      $t0, 0              # $t0 = i = 0
        move    $t2, $s3            # $t2 = sub2
for_l2:
        addi    $t2, $t2, 4         # $t2 = sub2[i:]
        bge     $t0, $s1, for_l2_done
        # sub2[i] = a[i + l1];
        lw      $t3, 0 ($t1)        # $t3 = a[i + l1]
        sw      $t3, 0 ($t2)        # sub2[i] = $t3
        addi    $t1, $t1, 4         # $t1 = a[i:]
        addi    $t0, $t0, 1         # $t0 = i++
        beq     $0, $0, for_l2
for_l2_done:

        # sub1 = Merge_Sort(sub1);
        addi    $sp, $sp, -4        # adjust stack for $a0
        sw      $a0, 0 ($sp)
        move    $a0, $s2            # $a0 = sub1
        jal     merge_sort_inner
        # sub2 = Merge_Sort(sub2);
        move    $a0, $s3            # $a0 = sub2
        jal     merge_sort_inner
        lw      $a0, 0 ($sp)
        addi    $sp, $sp, 4         # adjust stack back

        # recombine to one array
        lw      $t0, 0 ($a0)        # $t0 = a.length
        # int c1 = 0;
        li      $t1, 0              # $t1 = c1 = 0
        # int c2 = 0;
        li      $t2, 0              # $t2 = c2 = 0
        # for (int i = 0; i < a.length; i++) {
        li      $t3, -1             # $t3 = i = 0
        move    $t4, $a0            # $t4 = a
        move    $t5, $s2            # $t5 = sub1
        addi    $t5, $t5, 4         # $t5 = sub1[c1:]
        move    $t6, $s3            # $t6 = sub2
        addi    $t6, $t6, 4         # $t6 = sub2[c2:]
for_combine:
        addi    $t4, $t4, 4         # $t4 = a[i:]
        addi    $t3, $t3, 1         # $t3 = i++
        bge     $t3, $t0, for_combine_done
        # if sub1 empty, take from sub2
        # if (c1 >= l1)
        blt     $t1, $s0, if_sub2_e
        # a[i] = sub2[c2++];
        lw      $t9, 0 ($t6)        # $t9 = sub2[c2]
        sw      $t9, 0 ($t4)        # a[i] = $t9
        addi    $t2, $t2, 1         # $t2 = c2++
        addi    $t6, $t6, 4         # $t6 = sub2[c2++:]
        beq     $0, $0, for_combine
if_sub2_e:
        # else if (c2 >= l2)
        blt     $t2, $s1, if_sub1_smaller
        # a[i] = sub1[c1++];
        lw      $t9, 0 ($t5)        # $t9 = sub1[c1]
        sw      $t9, 0 ($t4)        # a[i] = $t9
        addi    $t1, $t1, 1         # $t1 = c1++
        addi    $t5, $t5, 4         # $t5 = sub1[c1++:]
        beq     $0, $0, for_combine
if_sub1_smaller:
        # else if (sub1[c1] < sub2[c2])
        lw      $t7, 0 ($t5)        # $t7 = sub1[c1]
        lw      $t8, 0 ($t6)        # $t8 = sub2[c2]
        bge     $t7, $t8, if_sub2_smaller
        # a[i] = sub1[c1++];
        sw      $t7, 0 ($t4)        # a[i] = $t7
        addi    $t1, $t1, 1         # $t1 = c1++
        addi    $t5, $t5, 4         # $t5 = sub1[c1++:]
        beq     $0, $0, for_combine
if_sub2_smaller:
        # else
        # a[i] = sub2[c2++];
        sw      $t8, 0 ($t4)        # a[i] = $t8
        addi    $t2, $t2, 1         # $t2 = c2++
        addi    $t6, $t6, 4         # $t6 = sub2[c2++:]
        beq     $0, $0, for_combine

for_combine_done:
        # have to deallocate sub1 and sub2 from the stack
        li      $t0, 4
        mul     $s1, $s1, $t0
        add     $sp, $sp, $s1       # adjust by l2
        addi    $sp, $sp, 4         # adjust the l2 value out
        mul     $s0, $s0, $t0
        add     $sp, $sp, $s0       # adjust by l1
        addi    $sp, $sp, 4         # adjust the l1 value out
        beq     $0, $0, return

return:
        # return a;
        move    $v0, $a0            # $v0 = a

        lw      $s3, 0x10 ($sp)
        lw      $s2, 0x0C ($sp)
        lw      $s1, 0x08 ($sp)
        lw      $s0, 0x04 ($sp)
        lw      $ra, 0x00 ($sp)     # return address back
        addi    $sp, $sp, 20        # return stack pointer
        jr      $ra

error:
        # return null;
        move    $v0, $0             # set $a0 to null
        jr      $ra
