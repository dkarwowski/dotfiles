CSE4102

# Scope
 • scope ends when program ends
 • starts the line after declared
{{{sml val x = 3;}}}
 • We can have local binding
    ◦ scheme with syntax
{{{sml
let
   expression
in
   stuffs and things
end;
}}}
    ◦ local scope overrides other variables
    ◦ evaluates to the last expression when in interpreter
    ◦ let statements will be the most common
 • `val it` is the last evaluated item

# Types
 • Is computed → type inference
{{{sml
- val x = 42;
val x = 42 : int
}}}
 • Can be specified → type constraint
{{{sml
- val x = 42 : int;
}}}
 • Type of the expression based on sub-expression
 • Type will be brought up later on
 • Why do we need type constraints?
    ◦ inference can go horribly wrong
    ◦ inference is sometimes beyond exponential time (causes failure)

## Tuples
 • Used to organize info
    ◦ pairs, triples, tuples ← more general
 • Do not have to be mono-type (like Python)
 • Can be accessed iteratively → only hardcoded
 • Can be unpacked as well, can use “...” to ignore
{{{sml
- val x = (3, 4);
val x = (3, 4) : int * int
- #1(x)
val it = 3
- val (a, b) = x;
val a = 3 : int
val b = 3 : int
}}}
## Records
 • A named tuple
{{{sml
- val x = { name = "Donkey", age = 3 };
val x = {age=3, name="Donkey"} : { age : int, name : string }
- #age(3)
val it = 3 : int
- val {name=a, age=b} = x;
val a = "Donkey" : string
val b = 3 : int
}}}
 • can’t use numbers to access these fields
 • will ignore if you set a named value to itself in unpacking
{{{sml
- val {name="Donkey", age=c} = x;
val c = 3 : int
}}}
 • can use partial matching
{{{sml
- val {name=d, ...} = x;
val d = "Donkey" : string
}}}
# Expressions

 • what do we need?
    ◦ arithmetic
    ◦ boolean
    ◦ conditionals

## Arithmetic

 • Binary: 
    ◦ +, -, *, /, mod
 • Unary:
    ◦ ~ [negative, the _tilde_]
 • Works with literals, names with types
 • Cannot mix int and reals
 • Handles precedence properly

## Boolean

 • Conjunction (and) → andalso
 • Disjunction (or)  → orelse
 • Negation    (not) → not
 • ‘=’ is a comparison or assignment
    ◦ only an assignment if there’s a val (matches first equal)

## Conditional

 • Make a decision and branch
 • Is an expression
    ◦ A Condition
    ◦ A consequenct (if true)
    ◦ An alternate (if false)
{{{sml
- val x = 4;
val x = 4 : int
- val z = if x = 4 then ("Hello", true) else ("Bye", false);
val z = {"Hello" : string, true : bool}
}}}

# Functions

 • What is a function?
    ◦ takes input, gives one output
 • Why use it?
    ◦ Black-boxes the information
    ◦ Can be reused
    ◦ Just really a value (first-class data type)
{{{c
int hello(int x) {
   static int c = 0;
   int y = x * c;
   c = c + 1;
   return y;
}
}}}
 • This is not really a function, because it relies on the static int
 • Basic syntax:
    ◦ `fun <id> <param> = <expression>;`
{{{sml
- fun succ x = x + 1;
val succ = fn : int -> int
}}}
 • Applications
{{{sml
-succ 3;
val it = 4 : int
}}}

## Parameters

 • Pass by value
    ◦ none-pointer in C
 • Pass by reference
    ◦ pointer in C
 • Pass by name

## Anonymous Function

 • `fn <param> => <expression>;`

{{{sml- fn x => x+1;
val it = fn : int -> int
}}}{{{sml
- val succ = fn x => x+1;
val succ = fn : int -> int
}}}
