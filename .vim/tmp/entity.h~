#ifndef _ENTITY_H_
#define MAX_ENTITIES 256

#define _E_TYPE(type, i) ETYPE_##type = (1 << i)

typedef enum {
    ETYPE_dead   = 0,

    _E_TYPE(player, 0),
    _E_TYPE(bullet, 1),
    _E_TYPE(wall,   2),
    _E_TYPE(enemy,  3)
} ETYPE;

// TODO(david): better way?
typedef struct {
    v2 direction;
} ENT_player;

typedef struct {
    u32 timeAlive;
    u32 maxTime;
} ENT_bullet;

typedef struct {
} ENT_wall;

typedef struct {
    u32 maxHP;
    u32 HP;
} ENT_enemy;

#define _E_STRUCT(type) struct {ENT_##type e##type;}

// Macros to read things easier
#define E_IsType(entity_p, type) (entity_p->etype == ETYPE_##type)
#define E_Get(evar, entity_p, type) ENT_##type *evar = ( E_IsType(entity_p, type) ) ? (ENT_##type *)(&entity_p->e##type) : NULL // TODO(david): is this necessary?

// TODO(david): generalize so that each "type" has a parent values
typedef struct {
    world_pos pos;
    r32 speed;
    r32 drag;
    r32 mass;
    v2 vel;
    v2 force;

    v2 collRect;
    u32 collFlag; //NOTE(david): things that it collides WITH

    v4 drawCol;
    v2 drawOffset;
    v2 drawDim;

    u32 eid;
    u32 etype;
    bool dead;

    union {
        _E_STRUCT(player);
        _E_STRUCT(bullet);
        _E_STRUCT(wall);
        _E_STRUCT(enemy);
    };
} entity;

// NOTE: if next has a value but prev == 0,
// then we're pointing to the next position free
// TODO(david): see if previous is ever necessary
typedef struct store_entity {
    entity e;
    struct store_entity *next_p;
} store_entity;

// TODO(david): have this keep a pointer to the first *empty* element -> no need for last
// empty elements point to the next empty elements there too
// TODO(david): use first to iterate over them, next will point to next in contiguous memory that is alive
typedef struct {
    store_entity entity[MAX_ENTITIES];
    store_entity *last_p;
    store_entity *lastDeleted_p;
    u32 numEntities; // can still iterate using this
} entity_manager;

#define _ENTITY_H_
#endif
