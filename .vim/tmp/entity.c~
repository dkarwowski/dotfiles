// TODO(david): move this out to game.h if it works
#define CountOffset(base, current, type) (((iptr)current - (iptr)base)/sizeof(type))
#define E_NO_EMPTIES (emanager_p->last_p->next_p == NULL)

local entity *
E_AddEntity(entity_manager *emanager_p)
{
    store_entity *result_p = NULL;
    u32 eid = 0;
    if (emanager_p->last_p != NULL) {
        if (E_NO_EMPTIES) {
            result_p = &emanager_p->entity[emanager_p->numEntities];
            eid = emanager_p->numEntities++;
//            printf("add-no-empty: %3d, %3d\n", eid, emanager_p->numEntities);
            emanager_p->last_p = result_p;
        }
        else {
            result_p = emanager_p->last_p->next_p;
            eid = CountOffset(emanager_p->entity, result_p, store_entity);
//            printf("add-ye-empty: %3d, %3d\n", eid, emanager_p->numEntities);
            emanager_p->last_p->next_p = result_p->next_p;
            ASSERT(eid < emanager_p->numEntities);
        }
        ZeroStruct((*result_p));
        (&result_p->e)->eid = eid;
    }
    else {
        u32 eid = emanager_p->numEntities++;
        result_p = &emanager_p->entity[eid];

        ZeroStruct((*result_p));
        result_p->e.eid = eid;

        emanager_p->last_p = result_p;
        emanager_p->lastDeleted_p = emanager_p->last_p;
    }

    ASSERT(result_p->e.eid == eid);
    ASSERT(result_p->next_p == NULL);
//    printf("add: %3d, %3d\n", result_p->e.eid, emanager_p->numEntities);
    return &(result_p->e);
}

local void
E_DeleteEntity(entity_manager *emanager_p, u32 eid)
{
    ASSERT(eid < emanager_p->numEntities);
    store_entity *delete_p = &emanager_p->entity[eid];

    // NOTE(david): set things to null/dead to remove loops
    delete_p->e.etype = ETYPE_dead;
    delete_p->next_p = NULL;

    if (emanager_p->last_p == delete_p) {
        // NOTE(david); we need to follow the delete list from last_p to
        // lastDeleted_p and remove everything that's above the new last_p
        while(E_IsType((&(emanager_p->entity[emanager_p->numEntities - 1].e)), dead)) {
//            printf("del-remmax: %3d\n", emanager_p->numEntities);
            emanager_p->numEntities = emanager_p->numEntities - 1;
        }
 
        store_entity *temp_p = emanager_p->last_p;
        while(temp_p->next_p != NULL) {
            if (CountOffset(emanager_p->entity, temp_p->next_p, store_entity) >= emanager_p->numEntities)
                temp_p->next_p = temp_p->next_p->next_p;
            else 
                temp_p = temp_p->next_p;
//            printf("del-next_p: %3d\n", (int)CountOffset(emanager_p->entity, temp_p->next_p, store_entity));
        }
        emanager_p->lastDeleted_p = temp_p;

        temp_p = &(emanager_p->entity[emanager_p->numEntities - 1]);
        temp_p->next_p = emanager_p->last_p->next_p;
        emanager_p->last_p = temp_p;
        ASSERT(CountOffset(emanager_p->entity, emanager_p->last_p, store_entity) == (emanager_p->numEntities - 1));
    }
    else {
        if (E_NO_EMPTIES)
            emanager_p->last_p->next_p = delete_p;
        else
            emanager_p->lastDeleted_p->next_p = delete_p;
    }
    emanager_p->lastDeleted_p = delete_p;

    ASSERT(emanager_p->last_p == &emanager_p->entity[emanager_p->numEntities - 1]);
//    printf("del: %3d, %3d\n", eid, emanager_p->numEntities);
}

local void
E_AddWall(entity_manager *emanager_p, u32 worldx, u32 worldy, v2 tileStart, v2 tileEnd)
{
    ASSERT(tileStart.x == tileEnd.x || tileStart.y == tileEnd.y);
    ASSERT(tileStart.x <= tileEnd.x && tileStart.y <= tileEnd.y);

    entity *result_p = E_AddEntity(emanager_p);

    result_p->pos = (world_pos){worldx, worldy, mulV2(0.5f, addV2(tileStart, tileEnd))};
    result_p->mass = 0.0f; // there is no mass!

    result_p->collRect = addV2(subV2(tileEnd, tileStart), V2(1.0f, 1.0f));

    result_p->drawDim = result_p->collRect;
    result_p->drawCol = V4(0, 0, 0, 255);
    result_p->drawOffset = V2(0.0f, 0.0f);

    result_p->etype = ETYPE_wall;
}

local entity *
E_AddPlayer(entity_manager *emanager_p)
{
    entity *result_p = E_AddEntity(emanager_p);

    result_p->pos = (world_pos){0};
    CenterWorldPos(&result_p->pos);
    result_p->speed = 35.0f;
    result_p->mass = 1.0f;
    result_p->drag = 1.1f;

    result_p->collRect = V2(0.9f, 0.4f);
    result_p->collFlag = ETYPE_wall;

    result_p->drawCol = V4(101, 155, 153, 255);
    result_p->drawDim = V2(0.9f, 1.2f);
    result_p->drawOffset = V2(0.0f, 0.4f);

    // Player specific things
    result_p->etype = ETYPE_player;
    result_p->eplayer.direction = V2(0.0f, -1.0f); // face down

    return result_p;
}

local void
E_AddBullet(entity_manager *emanager_p, v2 direction, world_pos pos)
{
    entity *tempEntity_p = E_AddEntity(emanager_p);

    tempEntity_p->pos = pos;
    tempEntity_p->drag = 1.0f;
    tempEntity_p->mass = 1.0f;
    tempEntity_p->vel = mulV2(15.0f, direction);

    tempEntity_p->collRect = V2(0.3f, 0.3f);
    tempEntity_p->collFlag = ETYPE_wall | ETYPE_enemy;

    tempEntity_p->drawCol = V4(125, 125, 255, 255);
    tempEntity_p->drawDim = V2(0.5f, 0.5f);

    tempEntity_p->etype = ETYPE_bullet;
}

local void
E_AddEnemy(entity_manager *emanager_p, world_pos pos)
{
    entity *temp_p = E_AddEntity(emanager_p);

    temp_p->pos = pos;
    temp_p->drag = 1.0f;
    temp_p->mass = 1.0f;
    temp_p->vel = V2(0.0f, 0.0f);

    temp_p->collRect = V2(0.9f, 1.2f);
    temp_p->collFlag = 0;

    temp_p->drawCol = V4(255, 125, 125, 255);
    temp_p->drawDim = V2(0.9f, 1.2f);

    temp_p->eenemy.HP = 10;

    temp_p->etype = ETYPE_enemy;
}

local bool
DidHitWall(r32 wallX, r32 minY, r32 maxY, v2 oldPos, v2 deltaPos, r32 *tMin_p) 
{
    bool hit = false;

    r32 epsilon = 0.001f;
    if (deltaPos.x != 0) {
        r32 t = (wallX - oldPos.x) / (deltaPos.x);
        r32 y = oldPos.y + t*(deltaPos.y);
        if (t > 0.0f && *tMin_p > t && maxY >= y && y >= minY) {
            *tMin_p = MAX(0, t-epsilon);
            hit = true;
        }
    }
    return hit;
}

local void
Move(entity_manager *emanager_p, entity *entity_p, r32 dt)
{
    ASSERT(entity_p->mass > 0.001); // anything without mass can't move

    entity_p->force = mulV2(entity_p->speed, NormalizeV2(entity_p->force));
    v2 acc = mulV2(1.0f/entity_p->mass, entity_p->force);
    entity_p->vel = addV2(mulV2(1.0f/entity_p->drag, entity_p->vel), mulV2(dt, acc));

    // NOTE(david): making sure we zero out vel (keeps from really low values)
    if (fequal(entity_p->vel.x, 0, 0.1f))
        entity_p->vel.x = 0;
    if (fequal(entity_p->vel.y, 0, 0.1f))
        entity_p->vel.y = 0;

    v2 dPos = mulV2(dt, entity_p->vel);

    // TODO(david): move collision to it's own thing (array of collision rects?)
    r32 tRem = 1.0f;
    for (i32 i = 0; (i < 4) && (tRem > 0.0f); i++) {
        v2 wallNormal = {0};
        r32 tMin = 1.0f;

        for (u32 i = 0; i < emanager_p->numEntities; i++) {
            entity *cmp_p = &(emanager_p->entity[i].e);
            if (cmp_p->dead || E_IsType(cmp_p, dead)) continue;

            if (cmp_p->etype & entity_p->collFlag) {
                v2 testDim = addV2(entity_p->collRect, cmp_p->collRect);
                v2 absPos = addV2(entity_p->pos.map, DiffWorldPos(&cmp_p->pos, &entity_p->pos));
                v2 minCorner = addV2(absPos, mulV2(-0.5f, testDim));
                v2 maxCorner = addV2(absPos, mulV2( 0.5f, testDim));
                v2 resultNormal = V2(0.0f, 0.0f);

                // check each wall of the against player's point
                if (DidHitWall(minCorner.x, minCorner.y, maxCorner.y, 
                            entity_p->pos.map, dPos, &tMin))
                    resultNormal = V2(-1, 0);
                if (DidHitWall(maxCorner.x, minCorner.y, maxCorner.y, 
                            entity_p->pos.map, dPos, &tMin))
                    resultNormal = V2(1, 0);
                if (DidHitWall(minCorner.y, minCorner.x, maxCorner.x, 
                            swapV2(entity_p->pos.map), swapV2(dPos), &tMin))
                    resultNormal = V2(0, -1);
                if (DidHitWall(maxCorner.y, minCorner.x, maxCorner.x, 
                            swapV2(entity_p->pos.map), swapV2(dPos), &tMin))
                    resultNormal = V2(0, 1);

                // TODO(david): this handling is only here to not iterate over the entities again
                if (E_IsType(entity_p, bullet) && !equalV2(resultNormal, V2(0.0f, 0.0f))) {
                    E_Get(enemy_p, cmp_p, enemy);
                    if (enemy_p) {
                        enemy_p->HP -= 1;
                        if (enemy_p->HP == 0) cmp_p->dead = true;
                    }
                }

                wallNormal = (equalV2(resultNormal, V2(0.0f, 0.0f))) ? wallNormal : resultNormal;
            }
        }

        // TODO(david): see about moving things out of here. 
        if (E_IsType(entity_p, bullet) && tMin < 1.0f) {
            entity_p->dead = true;
            break;
        }
        if (E_IsType(entity_p, player) || E_IsType(entity_p, bullet)) {
            entity_p->pos.map = addV2(entity_p->pos.map, mulV2(tMin, dPos));
            entity_p->vel = subV2(entity_p->vel, mulV2(innerV2(entity_p->vel, wallNormal), wallNormal));
            dPos = subV2(dPos, mulV2(innerV2(dPos, wallNormal), wallNormal));
            tRem -= tMin*tRem;
        }
    }

    if (E_IsType(entity_p, player) && !equalV2(entity_p->vel, V2(0.0f, 0.0f))) {
        entity_p->eplayer.direction = NormalizeV2(entity_p->vel);
    }

    FixWorldPos(&entity_p->pos);
}
