(* TODO: probably generally useful *)
fun DivInt(a : int, b : int) =
  (floor(Real.fromInt(a) / Real.fromInt(b)))

type machine_state = {a : int, b : int};
fun NewMachine(a, b) : machine_state = {a = a, b = b};

fun GetA(m : machine_state) = #a(m);
fun GetB(m : machine_state) = #b(m);

(* TODO: If/Then, For/While, Vars, Functions, Rectursion *)
datatype instruction = SetA of int | SetB of int | Add | Sub | Disp | Mult | Div;

fun i2s(SetA a) = "SetA " ^ Int.toString(a) ^ "\n"
  | i2s(SetB b) = "SetB " ^ Int.toString(b) ^ "\n"
  | i2s(Add)    = "Add" ^ "\n"
  | i2s(Sub)    = "Sub" ^ "\n"
  | i2s(Mult)   = "Mult" ^ "\n"
  | i2s(Div)    = "Div" ^ "\n"
  | i2s(Disp)   = "Disp -> "
  ;

fun eval(m : machine_state, SetA a) : machine_state =
    (NewMachine(a, #b(m)))
  | eval(m : machine_state, SetB b) : machine_state =
    (NewMachine(#a(m), b))
  | eval(m : machine_state, Add   ) : machine_state =
    (NewMachine(#a(m) + #b(m), #b(m)))
  | eval(m : machine_state, Sub   ) : machine_state =
    (NewMachine(#a(m) - #b(m), #b(m)))
  | eval(m : machine_state, Mult  ) : machine_state =
    (NewMachine(#a(m) * #b(m), #b(m)))
  | eval(m : machine_state, Div   ) : machine_state =
    (NewMachine(DivInt(#a(m), #b(m)), #b(m)))
  | eval(m : machine_state, Disp  ) : machine_state =
    (print(Int.toString(#a(m)) ^ "\n");
    m)
  ;

fun run(m : machine_state, [] : instruction list) = m
  | run(m : machine_state, prog : instruction list) = 
    let val instr = hd(prog)
      val instrs = tl(prog)
      val _ = print(i2s(instr));
      val m1 = eval(m, instr);
    in
      run(m1, instrs)
    end;

val m1    = NewMachine(0, 0);
val prog1 = [SetA 10, SetB 5, Add, SetB 2, Mult, Disp];
