= Contents =
  - [[#Scheduling|Scheduling]]
    - [[#Scheduling#Process Behavior|Process Behavior]]
    - [[#Scheduling#Algorithms|Algorithms]]
    - [[#Scheduling#Doing the scheduling|Doing the scheduling]]
      - [[#Scheduling#Doing the scheduling#batch system|batch system]]
      - [[#Scheduling#Doing the scheduling#interactive systems|interactive systems]]
      - [[#Scheduling#Doing the scheduling#real-time systems|real-time systems]]
  - [[#Definitions|Definitions]]

= Scheduling =
Scheduler needs to be done in an efficient way so that all required jobs need
to be right. We know how to ensure they don’t interfer already

== Process Behavior ==
* we can use bursts of usage alternating with waiting for I/O
* CPU bound process uses longer CPU bursts
* I/O bound process uses shorter CPU bursts

== Algorithms ==
Goals
* All systems
  * fair: give all some of the CPU
  * policy: seeing that policy is carried out
  * balance: keep it all busy
* Batch
  * throughput: jobs/hour (similar idea to below)
  * turnaround time: quickly done (faster turnaround → higher throughput)
  * cpu util: keep it busy all the time
* Interactive
  * response time: quick to react to input
  * proportionality: meet expectations
* Real Time
  * meeting deadlines: don’t lose data
  * predictability: avoid degrading

== Doing the scheduling ==
=== batch system ===
* first-come first-serve
  * a single queue
  * once blocked, move it to the end
  * disadvantages:
    * job computes 1 sec then do I/O, reptitive
    * → disk bound job needs to read 1000 disk block
    * → how long will the disk job take? (no way to really know)
* shortest job first
  * grab the shortest first, lower avg. turnaround time the best way
  * `[   8   | 4 | 4 | 4 ] = 14 = (8 + 12 + 16 + 20)/4`
  * `[ 4 | 4 | 4 |   8   ] = 10 = (4 + 8 + 12 + 16)/4`
  * Assume all of the above come in at the same time
  * _How does it know what’s shortest?_
    * Generally through a sort of estimation based on the last one
  * *only optimal when at the same time* 
  *  → it’s easy to show non-optimal but not easy to show optimality
    * consider 8 jobs w/ time 2, 4, 1, 1 & arrival 0, 0, 3, 3, 3
    * `[2| 4 |||] = 4.6 = (2 + 6 + 4 + 5 + 6)/5`
    * `[ 4 ||||2] = 4.4 = (4 + 2 + 3 + 4 + 9)/5`
* shortest remaining time next
  * whatever is almost done
  * new short jobs get done faster

=== interactive systems ===
* round-robin
  * list of processes, go through circle when quantum finishes
  * disadvantage → context switch overhead
* priority
  * each process has different priority
  * statically or dynamically assign it
  * always run the highest priority, can run those in whatever way
* multiple queues
  * set up classes when each class gets an increasing quanta
  * if you need more time, move to the next class
  * good for those with high cost for swapping
* shortest next
  * based on estimate from past behavior
  * shortest estimated running time next
  * ages processes to ensure some process don’t wait too long
  {{$
  aT_0 + (1 - a)T_1
  }}$
* guaranteed
  * w/ n users, each gets 1/n of the CPU
  * keep track of how much each process gets, how much supposed to
  * adjust as processes finish/start
* lottery scheduling
  * give each lottery tickets
  * pick one at random, that ticket gets resources
* fair-share escheduling
  * one user w/ 9, another user w/ 1
  * owner/admin gets more resources

=== real-time systems ===
* what if there are m events that must get handled immediately?
* cannot be made as fair scheduling
* fairness doesn’t help meet deadlines
  * five homeworks, one is due in half hour → that one is first
* cowboy scheduling:
  * feed horse every 20 min for 10 min
  * feed cow every 50 min for 25 min
* _important questions_
  * what is guaranteed to meet all deadlines?
  * how do we know that it works for a given workload?
  * is there an “optimal” scheduler independent of workload?

----

= Definitions =
 * algorithm
    * logical procedure
    * informally specified
 * program
    * implementation of algorithm
    * can use different inputs
 * job
    * instance with specific inputs

----

= Job Scheduling =
