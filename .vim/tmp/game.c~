#include "game.h"
#include "world.c"
#include "entity.c"

local void
DrawRect(SDL_Renderer *renderer_p, v2 pos, v2 dim, bool center)
{
    int screenHeight;
    SDL_RenderGetLogicalSize(renderer_p, NULL, &screenHeight);
    u32 tileSide = screenHeight / 18;

    if (center) {
        SDL_RenderFillRect(
                renderer_p,
                &(SDL_Rect){
                    (i32)round((pos.x - dim.w/2) * tileSide),
                    screenHeight - (i32)round((pos.y + dim.h/2) * tileSide),
                    dim.w * tileSide, dim.h * tileSide
                }
        );
    }
    else {
        SDL_RenderFillRect(
                renderer_p,
                &(SDL_Rect){
                    (i32)round(pos.x * tileSide),
                    screenHeight - (i32)round(pos.y * tileSide),
                    dim.w * tileSide, dim.h * tileSide
                }
        );
    }
}

extern void
UpdateAndRender(game_memory *memory_p, game_input *input_p, SDL_Renderer *renderer_p)
{
    game_state *state_p = memory_p->permMem;
    game_temp *temp_p = memory_p->tempMem; //unused for now

    // ensure a clean exit (moves game_state out of main)
    if (input_p->terminate.endedDown) {
        TTF_CloseFont(state_p->font);
        return;
    }

    // try initializing and get out of here if failed (couldn't grab font)
    // TODO(david): don't bother rendering fonts if you fail?
    if (!memory_p->isInitialized) {
        InitMemStack(
                &state_p->stack,
                (void *)((iptr)memory_p->permMem + sizeof(game_state)),
                memory_p->permMemSize - sizeof(game_state)
        );
        InitMemStack(
                &temp_p->stack,
                (void *)((iptr)memory_p->tempMem + sizeof(game_temp)),
                memory_p->tempMemSize - sizeof(game_temp)
        );

        // Create all walls around current world
        for (int i = 0; i < 4; i++) {
            E_AddWall(&state_p->emanager, i, 0, V2(0.5f, 0.5f), V2(MAP_DIM - 0.5f, 0.5f));
            E_AddWall(&state_p->emanager, i, 0, V2(0.5f, MAP_DIM - 0.5f), V2(MAP_DIM - 0.5f, MAP_DIM - 0.5f));
            if (i == 0)
                E_AddWall(&state_p->emanager, i, 0, V2(0.5f, 0.5f), V2(0.5f, MAP_DIM - 0.5f));
            if (i == 3)
                E_AddWall(&state_p->emanager, i, 0, V2(MAP_DIM - 0.5f, 0.5f), V2(MAP_DIM - 0.5f, MAP_DIM - 0.5f));
        }

        state_p->player.e_p = E_AddPlayer(&state_p->emanager);

        world_pos enemyPos = state_p->player.e_p->pos;
        enemyPos.map = addV2(enemyPos.map, V2(1, 1));
        E_AddEnemy(&state_p->emanager, enemyPos);

        state_p->camera.pos = state_p->player.e_p->pos;
        state_p->camera.radius = V2(16, 9);

        state_p->debug.fpsDisplay = false;

        state_p->font = TTF_OpenFont("DejaVuSans.ttf", 24);
        if (state_p->font == NULL) {
            printf("failed font: %s\n", TTF_GetError());
        }

        InitWorld(&state_p->world, &state_p->stack);
        memory_p->isInitialized = true;
    }

    // TODO(david): deal with controls better
    { // Handle Input
        game_player *player_p = &(state_p->player);
        entity_manager *emanager_p = &(state_p->emanager);

        player_p->e_p->force = V2(0, 0);
        if (input_p->moveUp.endedDown)
            player_p->e_p->force.y += 1;
        if (input_p->moveLeft.endedDown)
            player_p->e_p->force.x += -1;
        if (input_p->moveDown.endedDown)
            player_p->e_p->force.y += -1;
        if (input_p->moveRight.endedDown)
            player_p->e_p->force.x += 1;

        // Runs updates for code stuffs
        for (int i = 0; i < emanager_p->numEntities; i++) {
            if (E_IsType((&emanager_p->entity[i].e), dead)) continue; // TODO(david): condense this
            if (emanager_p->entity[i].e.dead) E_DeleteEntity(emanager_p, i);

            // NOTE(david): anything without mass can't move!
            if (emanager_p->entity[i].e.mass > 0.0001f)
                Move(&state_p->emanager, &emanager_p->entity[i].e, input_p->dt);
        }

        v2 temp = DiffWorldPos(&player_p->e_p->pos, &state_p->camera.pos);
        MoveWorldPos(&state_p->camera.pos, mulV2(1.0f, temp));

        // Create an enemy if there's room
        static u32 pause = 100;
        if (input_p->action.endedDown) {
            // assuming they all have moving/renders
            if (emanager_p->numEntities < MAX_ENTITIES && pause >= 20) {
                E_AddBullet(emanager_p, player_p->e_p->eplayer.direction, player_p->e_p->pos);
                pause = 0;
            }
        }
        if (pause <= 20)
            pause++;

#ifdef DEBUG
        state_p->debug.fpsDisplay = (!input_p->debug.endedDown && (input_p->debug.halfTransitionCount/2)%2);
#endif
    }

    { // Rendering Shit
        // TODO(david): Move rendering to function
        SDL_SetRenderDrawColor(renderer_p, 125,125,125, 255);
        SDL_RenderClear(renderer_p);

        // TODO(david); clean this bs up...
        // TODO(david): need a tile int pair & a separate offset
        world_camera *cam_p = &state_p->camera;

        // TODO(david): have renderer keep track of its own entities
        // TODO(david): renderer should know position (separate from physics?)
        // should iterate render entities
        for (int i = 0; i < state_p->emanager.numEntities; i++) {
            entity *ent_p = &state_p->emanager.entity[i].e;
            if (ent_p->dead || E_IsType(ent_p, dead)) continue;
            SDL_SetRenderDrawColor(renderer_p, RGBA_PARAMS(ent_p->drawCol));
            v2 playerPos = DiffWorldPos(&ent_p->pos, &cam_p->pos);
            DrawRect(renderer_p, addV2(addV2(V2(16, 9), ent_p->drawOffset), playerPos), ent_p->drawDim, true);

            // NOTE(david): TERRIBLE SHITTY HEALTH DRAWING
            if (E_IsType(ent_p, enemy)) {
                E_Get(enemy_p, ent_p, enemy); // always gonna be non-null
                SDL_SetRenderDrawColor(renderer_p, 255, 50, 50, 255);
                v2 drawDim = V2(ent_p->drawDim.x + 0.4, 0.2);
                v2 botLeft = addV2(
                        addV2(addV2(V2(16, 9), ent_p->drawOffset), playerPos), 
                        V2(-(drawDim.x/2), -(ent_p->drawDim.y/1.3f)));
                drawDim = hadamardV2(
                        V2((r32)enemy_p->HP/(r32)enemy_p->maxHP, 1.0f), 
                        drawDim);
                DrawRect(renderer_p, botLeft, drawDim, false);
            }
        }

        if (state_p->font && state_p->debug.fpsDisplay) {
            char fps[4];
            sprintf(fps, "%3d", (u32)(1.0f/input_p->dt));
            SDL_Surface *fpsSurface_p = TTF_RenderText_Solid(state_p->font, fps, (SDL_Color){255, 255, 255, 255});
            SDL_Texture *fpsTexture_p = SDL_CreateTextureFromSurface(renderer_p, fpsSurface_p);
            i32 fpsWidth, fpsHeight;
            SDL_QueryTexture(fpsTexture_p, NULL, NULL, &fpsWidth, &fpsHeight);
            SDL_RenderCopy(renderer_p, fpsTexture_p, NULL, &(SDL_Rect){10, 10, fpsWidth+10, fpsHeight+10});
            SDL_FreeSurface(fpsSurface_p);
            SDL_DestroyTexture(fpsTexture_p);
        }

        SDL_RenderPresent(renderer_p);
    }
}

