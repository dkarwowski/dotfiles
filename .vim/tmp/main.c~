#include <SDL2/SDL.h>
#include "common.h"
#include "game.h"

#define GOAL_FPS 60

// Global variables
static game_player player;

void
ProcessKeyboardInput(game_control *old_p, game_control *new_p, bool isDown)
{
    new_p->endedDown = isDown;
    new_p->transitionCount += (old_p->endedDown == new_p->endedDown) ? 0 : 1;
}

/**
 * Grab an do something with an event
 * Return true if we're quitting, false otherwise
 */
bool
HandleEvent(SDL_Event *event_p, game_input *old_p, game_input *new_p)
{
    bool result = false;
    switch (event_p->type) {
        case SDL_KEYDOWN:
        case SDL_KEYUP:
        {
            bool wasDown = (event_p->key.repeat != 0 || event_p->key.state == SDL_RELEASED) ? true : false;
            bool isDown = (event_p->key.repeat != 0 || event_p->key.state == SDL_PRESSED) ? true : false;
            if (wasDown != isDown) {
                if (event_p->key.keysym.sym == SDLK_w)
                    ProcessKeyboardInput(&(old_p->moveUp), &(new_p->moveUp), isDown);
                if (event_p->key.keysym.sym == SDLK_a)
                    ProcessKeyboardInput(&(old_p->moveLeft), &(new_p->moveLeft), isDown);
                if (event_p->key.keysym.sym == SDLK_s)
                    ProcessKeyboardInput(&(old_p->moveDown), &(new_p->moveDown), isDown);
                if (event_p->key.keysym.sym == SDLK_d)
                    ProcessKeyboardInput(&(old_p->moveRight), &(new_p->moveRight), isDown);
                if (event_p->key.keysym.sym == SDLK_SPACE)
                    ProcessKeyboardInput(&(old_p->action), &(new_p->action), isDown);
            }

            if (event_p->key.keysym.sym == SDLK_ESCAPE)
                result = true;
            break;
        }
        case SDL_WINDOWEVENT:
        {
            break;
        }
        case SDL_QUIT:
        {
            result = true;
            break;
        }
        default:
            break;
    }

    return result;
}

bool
InitializeWindowAndRenderer(SDL_Window **window_p, SDL_Renderer **renderer_p)
{
    bool result = true;

    if (SDL_Init(SDL_INIT_VIDEO) < 0) {
        printf("Error initializing: %s\n", SDL_GetError());
        result = -1;
    }
    else {
        // Grab the window we need
        *window_p = SDL_CreateWindow(
                "Fluss",
                SDL_WINDOWPOS_CENTERED,
                SDL_WINDOWPOS_CENTERED,
                800,
                600,
                SDL_WINDOW_RESIZABLE
        );

        // Check if the window is valid
        if (*window_p == NULL) {
            printf("Error Creating Window: %s\n", SDL_GetError());
            result = -1;
        }
        else {
            // grab the renderer!
            *renderer_p = SDL_CreateRenderer(
                    *window_p, 
                    -1, 
                    SDL_RENDERER_ACCELERATED
            );

            if (*renderer_p == NULL) {
                printf("Error Creating Renderer: %s\n", SDL_GetError());
                result = -1;
            }
        }
    }
    return result;
}

int
main(int argc, char **argv)
{
    SDL_Window *window_p;
    SDL_Renderer *renderer_p;
    // Initialization
    if (InitializeWindowAndRenderer(&window_p, &renderer_p)) {
        // TODO: remove this shit
        // initialize the player
        player.rect.x = 300;
        player.rect.y = 300;
        player.rect.w = 25;
        player.rect.h = 25;
        player.col.r = 101;
        player.col.g = 155;
        player.col.b = 153;
        player.col.a = 255;

        // TODO: remove this shit
        // initialize inputs to 0
        game_input old_input = {0};
        game_input new_input = {0};

        // ensure fps
        uint64_t startCount = SDL_GetPerformanceCounter();
        uint64_t performanceFrequency = SDL_GetPerformanceFrequency();

        // Handle Events
        bool done = false;
        while (!done) {
            // swap old and new input
            old_input = new_input;
            // grab all event and deal with them
            SDL_Event event;
            while (SDL_PollEvent(&event)) {
                done = HandleEvent(&event, &old_input, &new_input);
            }

            // TODO: deal with controls better
            // game movement logic
            if (new_input.moveUp.endedDown)
                player.yVel = -100;
            else if (new_input.moveDown.endedDown)
                player.yVel = 100;
            else
                player.yVel = 0;
            if (new_input.moveLeft.endedDown)
                player.xVel = -100;
            else if (new_input.moveRight.endedDown)
                player.xVel = 100;
            else 
                player.xVel = 0;
            if (new_input.action.endedDown)
                player.col.a += 10;

            // TODO: generalize rendering
            SDL_SetRenderDrawColor(renderer_p, 154, 100, 102, 255);
            SDL_RenderClear(renderer_p);
            SDL_SetRenderDrawColor(
                    renderer_p,
                    player.col.r,
                    player.col.g,
                    player.col.b,
                    player.col.a
            );
            SDL_RenderFillRect(renderer_p, &player.rect);
            SDL_RenderPresent(renderer_p);

            // TODO: get rid of FPS capping
            while (performanceFrequency / (SDL_GetPerformanceCounter() - startCount) > GOAL_FPS)
                SDL_Delay(1);

            // TODO: moving is outside of timing
            MOVE(player, (SDL_GetPerformanceCounter() - startCount)/(double)performanceFrequency);
            startCount = SDL_GetPerformanceCounter();
        }

        SDL_DestroyRenderer(renderer_p);
        SDL_DestroyWindow(window_p);
        SDL_Quit();
        return 0;
    }
    else {
        return -1;
    }
}
