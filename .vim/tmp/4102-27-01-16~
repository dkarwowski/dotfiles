4102-27-01-16

# Scope
 • scope ends when program ends
 • starts the line after declared
 • {{{sml val x = 3;}}}
 • We can have local binding
    ◦ scheme with syntax
      {{{sml let
         <expression>
      in
         <stuffs and things>
      end;}}}
    ◦ local scope overrides other variables
    ◦ evaluates to the last expression when in interpreter
    ◦ let statements will be the most common
 • {{{sml val it}}} is the last evaluated item

# Types
 • Is computed → type inference
   {{{sml- val x = 42;
   val x = 42 : int}}}
 • Can be specified → type constraint
   {{{sml- val x = 42 : int;}}}
 • Type of the expression based on sub-expression
 • Type will be brought up later on
 • Why do we need type constraints?
    ◦ inference can go horribly wrong
    ◦ inference is sometimes beyond exponential time (causes failure)

## Tuples
 • Used to organize info
    ◦ pairs, triples, tuples ← more general
 • Do not have to be mono-type (like Python)
 • Can be accessed iteratively → only hardcoded
 • Can be unpacked as well, can use “...” to ignore
   {{{sml
   - val x = (3, 4);
   val x = (3, 4) : int * int
   - #1(x)
   val it = 3
   - val (a, b) = x;
   val a = 3 : int
   val b = 3 : int
   }}}
## Records
 • A named tuple
   {{{sml
   - val x = { name = "Donkey", age = 3 };
   val x = {age=3, name="Donkey"} : { age : int, name : string }
   - #age(3)
   val it = 3 : int
   - val {name=a, age=b} = x;
   val a = "Donkey" : string
   val b = 3 : int
   }}}
 • can’t use numbers to access these fields
 • will ignore if you set a named value to itself in unpacking
   {{{sml
   - val {name="Donkey", age=c} = x;
   val c = 3 : int
   }}}
 • can use partial matching
   {{{sml
   - val {name=d, ...} = x;
   val d = "Donkey" : string
   }}}
# Expressions
 • what do we need?
    ◦ arithmetic
    ◦ boolean

## Arithmetic
 • Binary: 
    ◦ +, -, *, /, mod
 • Unary:
    ◦ ~ [negative, the _tilde_]
 • Works with literals, names with types
 • Cannot mix int and reals
 • Handles precedence properly

## Boolean
 • Conjunction (and) → andalso
 • Disjunction (or)  → orelse
 • Negation    (not) → not
 • ‘=’ is a comparison or assignment
    ◦ only an assignment if there’s a val (matches first equal)

