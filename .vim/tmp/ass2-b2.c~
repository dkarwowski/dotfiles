#include <stdio.h>
#include <unistd.h>
#include <pthread.h>

// has the queue
#include "list.c"

#define NUM_THREADS 4
#define MAX_PRODUCE 20000
#define MAX_CONSUME 20000

struct pc_data {
    struct queue *queue_p;
    pthread_mutex_t *mutex_p;
    pthread_cond_t *pcond_p;
    pthread_cond_t *ccond_p;
};

void *
Producer(void *data)
{
    struct pc_data *unpacked_p = (struct pc_data *)data;
    struct queue *queue_p = unpacked_p->queue_p;
    pthread_mutex_t *mutex_p = unpacked_p->mutex_p;
    pthread_cond_t *pcond_p = unpacked_p->pcond_p;
    pthread_cond_t *ccond_p = unpacked_p->ccond_p;

    int timesAsleep = 0;
    for (int i = 0; i < MAX_PRODUCE; i++) {
        // ensure that no one adds right now
        pthread_mutex_lock(mutex_p);
        
        // Ensure that the Queue isn't full, otherwise sleep
        while(IsQueueFull(queue_p)) {
            timesAsleep++;
            pthread_cond_wait(pcond_p, mutex_p);
        }

        // Push the next item produced (just the index)
        PushQueue(queue_p, i);

        // Ensure Consumer is awake
        pthread_cond_signal(ccond_p);

        // unlock that mutex
        pthread_mutex_unlock(mutex_p);
    }

    printf("producer: times asleep: %d\n", timesAsleep);
    pthread_exit(NULL);
}

void *
Consumer(void *data)
{
    struct pc_data *unpacked_p = (struct pc_data *)data;
    struct queue *queue_p = unpacked_p->queue_p;
    pthread_mutex_t *mutex_p = unpacked_p->mutex_p;
    pthread_cond_t *pcond_p = unpacked_p->pcond_p;
    pthread_cond_t *ccond_p = unpacked_p->ccond_p;

    int timesAsleep = 0;
    for (int i = 0; i < MAX_CONSUME; i++) {
        // ensure that no one adds right now
        pthread_mutex_lock(mutex_p);
        
        // Ensure that the Queue isn't full, otherwise sleep
        while(IsQueueEmpty(queue_p)) {
            timesAsleep++;
            pthread_cond_wait(ccond_p, mutex_p);
        }

        // Push the next item produced (just the index)
        int toConsume;
        PopQueue(&toConsume, queue_p);
//        printf("consumer: %d\n", toConsume);

        // Ensure Consumer is awake
        pthread_cond_signal(pcond_p);

        // unlock that mutex
        pthread_mutex_unlock(mutex_p);
    }

    printf("consumer: times asleep: %d\n", timesAsleep);
    pthread_exit(NULL);
}

int
main(int argc, char *argv[])
{
    pthread_t threads[NUM_THREADS];
    struct queue myQueue    = QUEUE_INITIALIZER;
    pthread_mutex_t myMutex = PTHREAD_MUTEX_INITIALIZER;
    pthread_cond_t myPCond  = PTHREAD_COND_INITIALIZER;
    pthread_cond_t myCCond  = PTHREAD_COND_INITIALIZER;

    struct pc_data pcdata = {
        &myQueue,
        &myMutex,
        &myPCond,
        &myCCond
    };

    printf("queue size: %d\n", MAX_QUEUE_SIZE);

    for (int i = 0; i < NUM_THREADS/2; i++) {
        pthread_create(&threads[i], NULL, Producer, (void *)(&pcdata));
    }

    for (int i = NUM_THREADS/2; i < NUM_THREADS; i++) {
        pthread_create(&threads[i], NULL, Consumer, (void *)(&pcdata));
    }

    pthread_exit(NULL);
    return (0);
}
